---
# Playbook: Update kubeconfig files to use nginx load balancer VIP
#
# Purpose: Updates server endpoint in kubeconfig files on all K8s cluster nodes
#          to use the load balancer VIP (192.168.10.250:6443) instead of direct
#          control plane node access
#
# Target: All Kubernetes control plane and worker nodes
# Dependencies: Task Group 4 must be complete (nginx LB operational)
# Spec: agent-os/specs/2025-11-05-nginx-lb-ha

- name: Update kubeconfig files to use load balancer VIP endpoint
  hosts: localhost
  become: no
  gather_facts: yes

  vars:
    # Load balancer VIP endpoint
    lb_vip: "192.168.10.250"
    lb_port: "6443"
    lb_endpoint: "https://{{ lb_vip }}:{{ lb_port }}"

    # Kubeconfig locations to update
    kubeconfig_paths:
      - "{{ ansible_env.HOME }}/.kube/config"
      - "/etc/kubernetes/admin.conf"

    # Backup timestamp format
    backup_timestamp: "{{ ansible_date_time.iso8601_basic_short }}"

  tasks:
    - name: Update kubeconfig with error handling
      block:
        - name: Display playbook information
          debug:
            msg:
              - "=============================================="
              - "Kubeconfig Update for Load Balancer"
              - "=============================================="
              - "Target Endpoint: {{ lb_endpoint }}"
              - "Backup Timestamp: {{ backup_timestamp }}"
              - "Target Hosts: {{ ansible_play_hosts | join(', ') }}"
              - "=============================================="

    - name: Check if kubectl is available
      command: which kubectl
      register: kubectl_check
      changed_when: false
      failed_when: false

    - name: Verify kubectl is installed
      fail:
        msg: "kubectl is not installed on this host. Please install kubectl first."
      when: kubectl_check.rc != 0

    - name: Find existing kubeconfig files
      stat:
        path: "{{ item }}"
      register: kubeconfig_stat
      loop: "{{ kubeconfig_paths }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"

    - name: Find user kubeconfig files
      stat:
        path: "{{ item }}"
      register: user_kubeconfig_stat
      loop: "{{ kubeconfig_paths }}"
      when: "not item.startswith('/etc/')"

    - name: Create list of existing kubeconfig files
      set_fact:
        existing_kubeconfigs: >-
          {{
            (kubeconfig_stat.results | default([]) + user_kubeconfig_stat.results | default([]))
            | selectattr('stat.exists', 'defined')
            | selectattr('stat.exists')
            | map(attribute='item')
            | list
          }}

    - name: Display kubeconfig files to update
      debug:
        msg: "Found {{ existing_kubeconfigs | length }} kubeconfig file(s): {{ existing_kubeconfigs | join(', ') }}"

    - name: Fail if no kubeconfig files found
      fail:
        msg: "No kubeconfig files found on this host. Nothing to update."
      when: existing_kubeconfigs | length == 0

    # Backup phase
    - name: Create backup of user kubeconfig files
      copy:
        src: "{{ item }}"
        dest: "{{ item }}.backup.{{ backup_timestamp }}"
        remote_src: yes
        mode: preserve
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"

    - name: Create backup of system kubeconfig files
      copy:
        src: "{{ item }}"
        dest: "{{ item }}.backup.{{ backup_timestamp }}"
        remote_src: yes
        mode: preserve
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"

    - name: Verify backups were created
      stat:
        path: "{{ item }}.backup.{{ backup_timestamp }}"
      register: backup_verification
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"
      failed_when: not backup_verification.stat.exists

    - name: Verify user backups were created
      stat:
        path: "{{ item }}.backup.{{ backup_timestamp }}"
      register: user_backup_verification
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"
      failed_when: not user_backup_verification.stat.exists

    # Update phase - using sed for in-place modification
    - name: Get current server endpoint from kubeconfig (for user files)
      shell: |
        kubectl --kubeconfig="{{ item }}" config view --minify -o jsonpath='{.clusters[0].cluster.server}'
      register: current_endpoints_user
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"
      changed_when: false

    - name: Get current server endpoint from kubeconfig (for system files)
      shell: |
        kubectl --kubeconfig="{{ item }}" config view --minify -o jsonpath='{.clusters[0].cluster.server}'
      register: current_endpoints_system
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"
      changed_when: false

    - name: Display current endpoints
      debug:
        msg:
          - "Current endpoints in kubeconfig files:"
          - "{{ (current_endpoints_user.results | default([]) + current_endpoints_system.results | default([])) | selectattr('stdout', 'defined') | map(attribute='stdout') | list | unique }}"

    - name: Update server endpoint in user kubeconfig files
      replace:
        path: "{{ item }}"
        regexp: 'server:\s+https://[^:\s]+:6443'
        replace: "server: {{ lb_endpoint }}"
        backup: no
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"
      register: update_result_user

    - name: Update server endpoint in system kubeconfig files
      replace:
        path: "{{ item }}"
        regexp: 'server:\s+https://[^:\s]+:6443'
        replace: "server: {{ lb_endpoint }}"
        backup: no
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"
      register: update_result_system

    # Validation phase
    - name: Validate kubeconfig syntax after update (user files)
      command: kubectl --kubeconfig="{{ item }}" config view
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"
      changed_when: false
      register: validation_user

    - name: Validate kubeconfig syntax after update (system files)
      command: kubectl --kubeconfig="{{ item }}" config view
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"
      changed_when: false
      register: validation_system

    - name: Verify updated server endpoint (user files)
      shell: |
        kubectl --kubeconfig="{{ item }}" config view --minify -o jsonpath='{.clusters[0].cluster.server}'
      register: updated_endpoints_user
      loop: "{{ existing_kubeconfigs }}"
      when: "not item.startswith('/etc/')"
      changed_when: false
      failed_when: updated_endpoints_user.stdout != lb_endpoint

    - name: Verify updated server endpoint (system files)
      shell: |
        kubectl --kubeconfig="{{ item }}" config view --minify -o jsonpath='{.clusters[0].cluster.server}'
      register: updated_endpoints_system
      loop: "{{ existing_kubeconfigs }}"
      become: yes
      become_user: root
      when: "item.startswith('/etc/')"
      changed_when: false
      failed_when: updated_endpoints_system.stdout != lb_endpoint

    # Connectivity test
    - name: Test connectivity to cluster through load balancer
      command: kubectl --kubeconfig="{{ existing_kubeconfigs[0] }}" get nodes
      changed_when: false
      register: connectivity_test
      failed_when: connectivity_test.rc != 0

    - name: Display connectivity test results
      debug:
        msg:
          - "=============================================="
          - "Connectivity Test Results"
          - "=============================================="
          - "{{ connectivity_test.stdout_lines }}"
          - "=============================================="

    - name: Display success message
      debug:
        msg:
          - "=============================================="
          - "Kubeconfig Update Complete"
          - "=============================================="
          - "Updated {{ existing_kubeconfigs | length }} kubeconfig file(s)"
          - "New endpoint: {{ lb_endpoint }}"
          - "Backup files created with timestamp: {{ backup_timestamp }}"
          - "Connectivity test: PASSED"
          - "=============================================="

      # Error handling and rollback
      rescue:
        - name: Display error message
          debug:
            msg:
          - "=============================================="
          - "ERROR: Kubeconfig update failed"
          - "=============================================="
          - "An error occurred during kubeconfig update."
          - "Backup files are available for rollback."
          - "=============================================="

        - name: Provide rollback instructions
          debug:
            msg:
              - "To rollback, run the following commands:"
              - "{% for config in existing_kubeconfigs %}"
              - "  cp {{ config }}.backup.{{ backup_timestamp }} {{ config }}"
              - "{% endfor %}"

        - name: Fail the playbook
          fail:
            msg: "Kubeconfig update failed. See error messages above."
