# nginx Load Balancer Configuration - Dual Purpose
# Generated by Ansible - DO NOT EDIT MANUALLY
#
# Purpose:
# 1. Layer 4 (TCP Stream) - Kubernetes API Server Load Balancing (port 6443)
# 2. Layer 7 (HTTP/HTTPS) - NodePort Services Load Balancing
#
# This configuration provides both K8s control plane access and NodePort service routing.

# ============================================
# STREAM BLOCK - Kubernetes API Server (Layer 4)
# ============================================
# Load balances TCP port 6443 traffic to control plane nodes
# Provides TLS passthrough for end-to-end encryption

stream {
    # Upstream for Kubernetes API servers (control plane nodes)
    upstream k8s_api_servers {
        {{ nginx_config.lb_method }};  # Load balancing method
{% for node in k8s_control_plane %}
        server {{ node.ip }}:{{ nginx_config.k8s_api_port }} max_fails={{ nginx_config.max_fails }} fail_timeout={{ nginx_config.fail_timeout }};
{% endfor %}
    }

    # Stream server for K8s API
    server {
        listen {{ nginx_config.k8s_api_port }};
        proxy_pass k8s_api_servers;
        proxy_timeout {{ nginx_config.k8s_api_proxy_timeout }};
        proxy_connect_timeout {{ nginx_config.k8s_api_proxy_connect_timeout }};
    }
}

# ============================================
# HTTP BLOCK - NodePort Services (Layer 7)
# ============================================
# Load balances HTTP/HTTPS traffic to worker nodes for NodePort services

http {
    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Gzip Settings
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;

    # ============================================
    # UPSTREAM DEFINITIONS - NodePort Services
    # ============================================
    # Each upstream targets worker nodes on the NodePort

{% for service in services %}
    # {{ service.description }}
    upstream {{ service.name }} {
        {{ nginx_config.lb_method }};  # Use least connections load balancing
{% for worker in k8s_workers %}
        server {{ worker.ip }}:{{ service.node_port }} max_fails={{ nginx_config.max_fails }} fail_timeout={{ nginx_config.fail_timeout }};
{% endfor %}
    }

{% endfor %}

    # ============================================
    # SERVER BLOCKS - NodePort Services
    # ============================================

    # ArgoCD UI (HTTP)
    server {
        listen {{ services[0].listen_port }};
        server_name _;

        location / {
            proxy_pass http://{{ services[0].name }};
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeouts
            proxy_connect_timeout {{ nginx_config.proxy_connect_timeout }};
            proxy_send_timeout {{ nginx_config.proxy_send_timeout }};
            proxy_read_timeout {{ nginx_config.proxy_read_timeout }};
        }
    }

    # ArgoCD UI (HTTPS)
    server {
        listen {{ services[1].listen_port }} ssl;
        server_name _;

        # Self-signed certificate (replace with proper certs in production)
        ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
        ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;

        # SSL Settings
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;

        location / {
            proxy_pass http://{{ services[1].name }};
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto https;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeouts
            proxy_connect_timeout {{ nginx_config.proxy_connect_timeout }};
            proxy_send_timeout {{ nginx_config.proxy_send_timeout }};
            proxy_read_timeout {{ nginx_config.proxy_read_timeout }};
        }
    }

    # Traefik Ingress (HTTP)
    server {
        listen {{ services[2].listen_port }};
        server_name _;

        location / {
            proxy_pass http://{{ services[2].name }};
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeouts
            proxy_connect_timeout {{ nginx_config.proxy_connect_timeout }};
            proxy_send_timeout {{ nginx_config.proxy_send_timeout }};
            proxy_read_timeout {{ nginx_config.proxy_read_timeout }};
        }
    }

    # Traefik Ingress (HTTPS)
    server {
        listen {{ services[3].listen_port }} ssl;
        server_name _;

        # Self-signed certificate (replace with proper certs in production)
        ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
        ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;

        # SSL Settings
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;

        location / {
            proxy_pass http://{{ services[3].name }};
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto https;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            # Timeouts
            proxy_connect_timeout {{ nginx_config.proxy_connect_timeout }};
            proxy_send_timeout {{ nginx_config.proxy_send_timeout }};
            proxy_read_timeout {{ nginx_config.proxy_read_timeout }};
        }
    }

    # ============================================
    # HEALTH CHECK ENDPOINT
    # ============================================
    # Simple health check endpoint for monitoring

    server {
        listen {{ nginx_config.health_check_port }};
        server_name _;

        location {{ nginx_config.health_check_path }} {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
